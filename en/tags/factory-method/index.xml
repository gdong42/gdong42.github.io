<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Factory Method on Gan&#39;s Blog - Dumps to digest.</title>
    <link>https://donggan.me/en/tags/factory-method/</link>
    <description>Recent content in Factory Method on Gan&#39;s Blog - Dumps to digest.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 02 Sep 2019 21:28:38 +0800</lastBuildDate>
    
	<atom:link href="https://donggan.me/en/tags/factory-method/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to Factory Pattern (2): Factory Method</title>
      <link>https://donggan.me/en/post/factory-pattern-2-factory-method/</link>
      <pubDate>Mon, 02 Sep 2019 21:28:38 +0800</pubDate>
      
      <guid>https://donggan.me/en/post/factory-pattern-2-factory-method/</guid>
      <description>In my last article about Factory Pattern, a simple and intuitive method was introduced to encapsulate product creation logic without exposing details. The problem is that once we add a new concrete product call we have to modify the Factory class. It is not very flexible and requires the factory depending all concrete product types. Although class registration techniques can be used to eliminate the couplings in some extent, they still have some major drawbacks that prevent them to be used extensively.</description>
    </item>
    
  </channel>
</rss>